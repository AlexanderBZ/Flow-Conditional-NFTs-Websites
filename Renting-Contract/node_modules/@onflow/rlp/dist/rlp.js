'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var buffer = require('buffer');

/**
 * Built on top of rlp library, removing the BN dependency for the flow.
 * Package : https://github.com/ethereumjs/rlp
 * RLP License : https://github.com/ethereumjs/rlp/blob/master/LICENSE
 *
 * ethereumjs/rlp is licensed under the
 * Mozilla Public License 2.0
 * Permissions of this weak copyleft license are conditioned on making available source code of licensed files and modifications of those files under the same license (or in certain cases, one of the GNU licenses). Copyright and license notices must be preserved. Contributors provide an express grant of patent rights. However, a larger work using the licensed work may be distributed under different terms and without source code for files added in the larger work.
 **/

/**
 * @param input - will be converted to buffer
 * @returns returns buffer of encoded data
 **/

function encode(input) {
  if (Array.isArray(input)) {
    var output = [];

    for (var i = 0; i < input.length; i++) {
      output.push(encode(input[i]));
    }

    var buf = buffer.Buffer.concat(output);
    return buffer.Buffer.concat([encodeLength(buf.length, 192), buf]);
  } else {
    var inputBuf = toBuffer(input);
    return inputBuf.length === 1 && inputBuf[0] < 128 ? inputBuf : buffer.Buffer.concat([encodeLength(inputBuf.length, 128), inputBuf]);
  }
}
/**
 * Parse integers. Check if there is no leading zeros
 * @param v The value to parse
 * @param base The base to parse the integer into
 */

function safeParseInt(v, base) {
  if (v.slice(0, 2) === "00") {
    throw new Error("invalid RLP: extra zeros");
  }

  return parseInt(v, base);
}

function encodeLength(len, offset) {
  if (len < 56) {
    return buffer.Buffer.from([len + offset]);
  } else {
    var hexLength = intToHex(len);
    var lLength = hexLength.length / 2;
    var firstByte = intToHex(offset + 55 + lLength);
    return buffer.Buffer.from(firstByte + hexLength, "hex");
  }
}
/**
 * Get the length of the RLP input
 * @param input
 * @returns The length of the input or an empty Buffer if no input
 */


function getLength(input) {
  if (!input || input.length === 0) {
    return buffer.Buffer.from([]);
  }

  var inputBuffer = toBuffer(input);
  var firstByte = inputBuffer[0];

  if (firstByte <= 0x7f) {
    return inputBuffer.length;
  } else if (firstByte <= 0xb7) {
    return firstByte - 0x7f;
  } else if (firstByte <= 0xbf) {
    return firstByte - 0xb6;
  } else if (firstByte <= 0xf7) {
    // a list between  0-55 bytes long
    return firstByte - 0xbf;
  } else {
    // a list  over 55 bytes long
    var llength = firstByte - 0xf6;
    var length = safeParseInt(inputBuffer.slice(1, llength).toString("hex"), 16);
    return llength + length;
  }
}
/** Check if a string is prefixed by 0x */


function isHexPrefixed(str) {
  return str.slice(0, 2) === "0x";
}
/** Removes 0x from a given String */


function stripHexPrefix(str) {
  if (typeof str !== "string") {
    return str;
  }

  return isHexPrefixed(str) ? str.slice(2) : str;
}
/** Transform an integer into its hexadecimal value */


function intToHex(integer) {
  if (integer < 0) {
    throw new Error("Invalid integer as argument, must be unsigned!");
  }

  var hex = integer.toString(16);
  return hex.length % 2 ? "0" + hex : hex;
}
/** Pad a string to be even */


function padToEven(a) {
  return a.length % 2 ? "0" + a : a;
}
/** Transform an integer into a Buffer */


function intToBuffer(integer) {
  var hex = intToHex(integer);
  return buffer.Buffer.from(hex, "hex");
}
/** Transform anything into a Buffer */


function toBuffer(v) {
  if (!buffer.Buffer.isBuffer(v)) {
    if (typeof v === "string") {
      if (isHexPrefixed(v)) {
        return buffer.Buffer.from(padToEven(stripHexPrefix(v)), "hex");
      } else {
        return buffer.Buffer.from(v);
      }
    } else if (typeof v === "number") {
      if (!v) {
        return buffer.Buffer.from([]);
      } else {
        return intToBuffer(v);
      }
    } else if (v === null || v === undefined) {
      return buffer.Buffer.from([]);
    } else if (v instanceof Uint8Array) {
      return buffer.Buffer.from(v);
    } else {
      throw new Error("invalid type");
    }
  }

  return v;
}

Object.defineProperty(exports, 'Buffer', {
  enumerable: true,
  get: function () { return buffer.Buffer; }
});
exports.encode = encode;
exports.getLength = getLength;
exports.toBuffer = toBuffer;
//# sourceMappingURL=rlp.js.map
